fn can_occur_before_semicolon(token : Token) -> Bool {
  match token {
    UIDENT(_)
    | LIDENT(_)
    | DOT_UIDENT(_)
    | DOT_LIDENT(_)
    | DOT_INT(_)
    | FLOAT(_)
    | INT(_)
    | BYTE(_)
    | BYTES(_)
    | TRUE
    | FALSE
    | STRING(_)
    | MULTILINE_STRING(_)
    | MULTILINE_INTERP(_)
    | INTERP(_)
    | CHAR(_)
    | RBRACE
    | RPAREN
    | RBRACKET
    | UNDERSCORE
    | BREAK
    | CONTINUE
    | RETURN
    | THROW
    | QUESTION
    | EXCLAMATION
    | RANGE_INCLUSIVE
    | RANGE_EXCLUSIVE
    | PIPE
    | ELLIPSIS
    | POST_LABEL(_) => true
    // ---------------------------
    TYPE
    | TYPEALIAS
    | STRUCT
    | SEMI(_)
    | PLUS
    | PACKAGE_NAME(_)
    | NEWLINE
    | MUTABLE
    | MINUS
    | MATCH
    | TRY
    | CATCH
    // | EXCEPT
    | LPAREN
    | LET
    | CONST
    | LBRACKET
    | LBRACE
    | INFIX1(_)
    | INFIX4(_)
    | INFIX3(_)
    | INFIX2(_)
    | IMPL
    | WITH
    | IMPORT
    | IF
    | GUARD
    | WHILE
    | ASYNC
    | FN
    | FAT_ARROW
    | THIN_ARROW
    | IN
    | EQUAL
    | AUGMENTED_ASSIGNMENT(_)
    | EOF
    | ENUM
    | ELSE
    | EXTERN
    | COMMENT(_)
    | COMMA
    | COLON
    | BARBAR
    | BAR
    | AS
    | IS
    | AMPERAMPER
    | DOTDOT
    | PUB
    | PRIV
    | READONLY
    | TRAIT
    | TRAITALIAS
    | DERIVE
    | COLONCOLON
    | TEST
    | LOOP
    | FOR
    | AMPER
    | CARET
    | RAISE
    | ATTRIBUTE(_) => false
  }
}


fn can_occur_after_semicolon(token : Token) -> Bool {
  match token {
    UIDENT(_)
    | LIDENT(_)
    | FLOAT(_)
    | INT(_)
    | BYTE(_)
    | BYTES(_)
    | TRUE
    | FALSE
    | STRING(_)
    | MULTILINE_STRING(_)
    | MULTILINE_INTERP(_)
    | INTERP(_)
    | CHAR(_)
    | LBRACE
    | LPAREN
    | LBRACKET
    | UNDERSCORE
    | BREAK
    | CONTINUE
    | RETURN
    | THROW
    | RAISE
    | TYPE
    | TYPEALIAS
    | STRUCT
    | TRAIT
    | TRAITALIAS
    | PACKAGE_NAME(_)
    | MUTABLE
    | MATCH
    | TRY
    | LET
    | CONST
    | IMPL
    | IMPORT
    | EXTERN
    | IF
    | GUARD
    | WHILE
    | ASYNC
    | FN
    | EOF
    | ENUM
    | PUB
    | PRIV
    | READONLY
    | TEST
    | LOOP
    | FOR
    | ELLIPSIS
    | POST_LABEL(_)
    | ATTRIBUTE(_) => true
    // the lexer should skip these two tokens before trying to insert semi
    COMMENT(_) | NEWLINE => true
    // [MINUS] is both a binary operator and a unary operator.
    // So it may occur on the beginning of a statement.
    // 
    // It is possible to *NOT* insert a semi before [MINUS].
    // If the user doesn't want a semi here, she can wrap the [MINUS] expression in parenthesis.
    // 
    // The choice we take here is to be more conservative and always insert a semi before [MINUS].
    // But this may change in the future.
    MINUS => true
    // Technically speaking, these infix operators cannot occur after semi.
    // However, we want to keep their behavior consistent with [MINUS] (see above).
    //
    // This would forbid the following pattern:
    //
    //   let x = expr1
    //     + expr2
    //     * expr3
    //
    // Users are instead forced to write:
    //
    //   let x = expr1 +
    //     expr2 *
    //     expr3
    //
    // But this may change in the future.
    // For example we may want to treat the pipeline operator "|>" specially
    // if it is added in the future.
    PLUS | INFIX1(_) | INFIX2(_) | INFIX3(_) | INFIX4(_) | AMPERAMPER | BARBAR | CARET | AMPER => true
    // It is possible to have a semi before [RBRACE].
    // However, this semi is optional for statement block.
    // So we choose to not insert a semi before [RBRACE].
    //
    // Inserting semis before [RBRACE] has bad interaction with record creation.
    // The user will be forced to add a comma after the last field definition for multi-line record creation
    RBRACE => false
    DOT_UIDENT(_)
    | DOT_LIDENT(_)
    | DOT_INT(_)
    | COLONCOLON
    | RPAREN
    | RBRACKET
    | SEMI(_)
    | FAT_ARROW
    | THIN_ARROW
    | IN
    | PIPE
    | EQUAL
    | AUGMENTED_ASSIGNMENT(_)
    | ELSE
    | CATCH
    // | EXCEPT
    | COMMA
    | COLON
    // Note that [BAR] is both "Pattern_or" and "Bitwise_or".
    | BAR
    | AS
    | IS
    | DOTDOT
    | DERIVE
    | WITH
    | QUESTION
    | RANGE_INCLUSIVE
    | RANGE_EXCLUSIVE
    | EXCLAMATION => false
  }
}

struct ASIContext {
  mut last_unhandled_newline : Int
}

fn ASIContext::new() -> ASIContext {
  ASIContext::{ last_unhandled_newline : -1 }
}

fn add_token[C](self : ASIContext, tokens~ : Array[(Token, Position, Position)], last_unhandled_comment~ : Ref[(C, Int)?], next_token : Token) -> Unit {

}